# Claude AI Agent Instructions for Aequitas Platform

## Overview

This document provides instructions for AI agents (like Claude Code) working on the Aequitas platform. **You MUST follow these instructions strictly** to ensure consistency, quality, and compliance with the project's workflow.

---

## Global Workflow Rules (Speckit-First)

### Pre-Implementation Checklist

**Before ANY coding, refactoring, or implementation task, you MUST:**

1. **Read the foundational documents:**
   - `.specify/constitution.md` - Project principles, technical standards, testing requirements
   - `.specify/README.md` - Speckit workflow guide
   - `README.md` - Project overview and setup instructions

2. **Detect the current git branch name:**
   ```bash
   git branch --show-current
   ```

3. **Check if the branch follows the feature branch convention:**
   - If the branch name starts with a **numeric feature ID** (e.g., `001-user-auth`, `042-analytics-dashboard`):
     - Extract the feature number (e.g., `001`, `042`)
     - Locate the matching folder under `specs/NNN-*/` (where `NNN` is the feature number)

   - **If the spec folder exists:**
     - Read the following files **in order**:
       - `specs/NNN-*/spec.md` - Feature requirements and acceptance criteria
       - `specs/NNN-*/plan.md` - Implementation strategy and phases
       - `specs/NNN-*/tasks.md` - Detailed task breakdown with estimates

   - **If the spec folder OR any required file (spec.md, plan.md, tasks.md) is missing:**
     - **STOP IMMEDIATELY** - Do NOT write or modify any code
     - Inform the user that the Speckit artifacts are missing
     - Propose to create the missing artifacts:
       - Use `/speckit-new` to create a new spec folder with `spec.md`
       - Use `/speckit-plan` to generate `plan.md` from the spec
       - Use `/speckit-tasks` to generate `tasks.md` from the plan
     - Only proceed with code changes **after** all Speckit artifacts are created

4. **Respect the spec boundaries:**
   - **NEVER** modify `backend/src/` or `frontend/src/` in ways not explicitly covered by the current `spec.md`, `plan.md`, and `tasks.md`
   - If you need to implement functionality not in the spec, **stop and ask the user** to update the spec first
   - The spec is the source of truth - code must match the spec, not the other way around

### Branch Naming Convention

- **Feature branches:** `NNN-feature-name` (e.g., `001-user-auth`, `012-task-adaptation`)
  - Where `NNN` is the feature number matching `specs/NNN-*/`
- **Hotfix branches:** `hotfix/description`
- **Chore branches:** `chore/description`

If the branch does NOT start with a numeric feature ID:
- You may proceed, but **inform the user** that Speckit validation is skipped
- This is typically used for documentation updates, tooling changes, or infrastructure work

---

## Husky Pre-Commit Hook Compliance

### Respect the Pre-Commit Checks

The project uses Husky pre-commit hooks to enforce Speckit compliance and run tests before commits.

**You MUST:**
- Always respect the pre-commit checks
- **NEVER** suggest or use `git commit --no-verify` unless explicitly requested by the user
- If the pre-commit hook fails, **fix the underlying issue** rather than bypassing the hook

**The pre-commit hook enforces:**
1. **Speckit validation:** All feature branches must have complete spec/plan/tasks artifacts
2. **Test execution:** All tests must pass before committing
3. **Empty commit prevention:** No commits if there are no staged changes

### If Pre-Commit Fails

1. **Read the error message carefully** - it will tell you what's wrong
2. **Fix the issue:**
   - If Speckit files are missing: Create them using `/speckit-plan` or `/speckit-tasks`
   - If tests are failing: Fix the failing tests before committing
   - If files are not staged: Stage the necessary files with `git add`
3. **Re-run the commit** - the hook will validate again

---

## Implementation Guidelines

### Code Quality Standards

- **TypeScript strict mode:** No `any` types without explicit justification
- **Consistent formatting:** Use existing ESLint and Prettier configurations
- **Clear naming:** Use descriptive variable, function, and class names
- **Comments:** Add comments for complex logic, not obvious code
- **DRY principle:** Don't Repeat Yourself - extract common logic into reusable functions

### Testing Requirements

**Every feature implementation MUST include:**

1. **Unit tests:**
   - Test all business logic, services, and utilities
   - Use Jest for backend (`npm test`)
   - Use Jest for frontend (`npm run test`)
   - Aim for >90% code coverage

2. **Integration tests:**
   - Test API endpoints with Supertest
   - Test database interactions
   - Verify service integrations

3. **Regression tests:**
   - Run the **complete test suite** after implementing ANY feature
   - Ensure no existing functionality is broken

4. **Build verification:**
   - Verify `npm run build` succeeds for both backend and frontend
   - Ensure no TypeScript errors or warnings

### Internationalization (i18n)

- **All user-facing strings MUST be in locale files** (not hardcoded)
- **Default language:** Spanish (es-AR)
- **Supported languages:** Spanish (es), English (en)
- Update `i18n/es.json` and `i18n/en.json` for any new UI text

### Security & Privacy

- **RBAC enforcement:** Always check user permissions before data access
- **Data sanitization:** Use DOMPurify for user-generated content
- **Secrets management:** NEVER hardcode secrets - use environment variables
- **SQL injection prevention:** Use TypeORM parameterized queries
- **XSS prevention:** Sanitize all user inputs

---

## AI-Specific Guidelines

### When Using LangChain/LangGraph

- **RAG queries:** Respect user permissions - only query data the user has access to
- **Prompt engineering:** Keep prompts clear, concise, and in the user's language
- **Error handling:** Always handle API failures gracefully
- **Token management:** Monitor token usage to avoid quota exhaustion
- **Human-in-the-loop:** AI generates suggestions, humans review and approve

### When Generating Specs/Plans/Tasks

- **Be specific:** Avoid vague requirements like "improve performance"
- **Be realistic:** Time estimates should account for testing and documentation
- **Be comprehensive:** Include edge cases, error handling, and validation
- **Be consistent:** Follow the format of existing specs/plans/tasks

---

## Documentation Requirements

### When to Update Documentation

**Always update documentation when:**
- Adding new features or endpoints
- Changing environment variables or configuration
- Adding new dependencies or scripts
- Modifying the architecture or data model
- Changing the development workflow

### What to Update

- `README.md` - Setup instructions, prerequisites, quick start
- `specs/NNN-*/spec.md` - If implementation deviates from original plan
- Inline code comments - JSDoc/TSDoc for all new functions and classes
- API documentation - Swagger annotations for new endpoints
- `i18n/*.json` - Translations for new UI strings

---

## Workflow Examples

### Example 1: Implementing a New Feature

```bash
# User: "Implement feature 007-notification-system"

# Step 1: Check current branch
git branch --show-current
# Output: 007-notification-system

# Step 2: Read foundational docs
cat .specify/constitution.md
cat .specify/README.md
cat README.md

# Step 3: Read spec artifacts
cat specs/007-notification-system/spec.md
cat specs/007-notification-system/plan.md
cat specs/007-notification-system/tasks.md

# Step 4: Implement according to plan and tasks
# ... write code ...

# Step 5: Write tests
# ... write unit and integration tests ...

# Step 6: Run tests
cd backend && npm test
cd ../frontend && npm run test

# Step 7: Build verification
cd backend && npm run build
cd ../frontend && npm run build

# Step 8: Update documentation
# ... update README, API docs, i18n files ...

# Step 9: Commit (pre-commit hook will validate)
git add .
git commit -m "feat(notifications): implement notification system"
```

### Example 2: Missing Speckit Artifacts

```bash
# User: "Implement feature 015-calendar-integration"

# Step 1: Check current branch
git branch --show-current
# Output: 015-calendar-integration

# Step 2: Try to read spec artifacts
cat specs/015-calendar-integration/spec.md
# Output: File not found

# Step 3: STOP - Inform user and propose solution
# "The spec folder for feature 015 is missing. I need to create
# the Speckit artifacts before proceeding. Let me create:
# 1. specs/015-calendar-integration/spec.md
# 2. Generate plan.md using /speckit-plan
# 3. Generate tasks.md using /speckit-tasks"

# Step 4: Create artifacts (don't code yet!)
# ... create spec.md, plan.md, tasks.md ...

# Step 5: NOW proceed with implementation
```

### Example 3: Pre-Commit Hook Failure

```bash
# User: "Commit my changes"

# Step 1: Stage changes
git add .

# Step 2: Try to commit
git commit -m "feat: add new feature"

# Output from pre-commit hook:
# ❌ COMMIT BLOCKED: No matching spec directory found for feature 020
# Expected: specs/020-feature-name/
# Create the folder and its spec.md/plan.md/tasks.md before committing.

# Step 3: Fix the issue - Create missing Speckit artifacts
# ... create specs/020-feature-name/ with all required files ...

# Step 4: Re-commit
git commit -m "feat: add new feature"
# Output: ✅ All Speckit checks and tests passed. Proceeding with commit.
```

---

## Prohibited Actions

**You MUST NEVER:**
- Bypass Husky pre-commit hooks with `--no-verify`
- Commit code without corresponding Speckit artifacts
- Skip writing tests for new features
- Hardcode secrets or API keys
- Use `any` types in TypeScript without justification
- Modify `backend/src/` or `frontend/src/` without a spec
- Push directly to `main` or `develop` branches
- Ignore ESLint or TypeScript errors
- Leave TODO comments without creating tasks
- Deploy without running tests and build verification

---

## Helpful Commands

### Speckit Workflow
- `/speckit-new` - Create a new feature spec
- `/speckit-plan` - Generate implementation plan from spec
- `/speckit-tasks` - Generate task breakdown from plan
- `/speckit-validate` - Validate all specs have required files

### Development
- `npm test` - Run tests (backend or frontend)
- `npm run build` - Build the project
- `npm run lint` - Run linter
- `npm run format` - Format code with Prettier
- `bash scripts/check-speckit.sh` - Validate Speckit structure

### Git
- `git branch --show-current` - Show current branch name
- `git status` - Show working tree status
- `git diff` - Show changes
- `git log --oneline -10` - Show recent commits

---

## When in Doubt

1. **Read the constitution:** `.specify/constitution.md` has the answers
2. **Check existing specs:** Look at `specs/001-006/` for detailed examples
3. **Run validation:** `bash scripts/check-speckit.sh`
4. **Ask the user:** If something is unclear, ask before proceeding

---

## Summary

**Remember the golden rule:**

> **No code without a spec. No commit without tests. No shortcuts.**

The Speckit-first workflow exists to ensure quality, consistency, and maintainability. Following it may seem slower at first, but it prevents technical debt, reduces bugs, and makes the codebase easier to maintain in the long run.

**Thank you for respecting these guidelines and helping build a better Aequitas platform!**

---

**Last Updated:** 2025-11-06
**Version:** 1.0
